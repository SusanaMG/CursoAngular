===============================================================================
===============================================================================
TEMA 01 Introduccion_ instalacion y estructura de archivos
**********************************************************

===============================================================================
Video 002: 002 Instalacion de Angular CLI

Para instalar TypeScript:
C:\Users\A702362>npm config set proxy http://10.89.0.72:84
C:\Users\A702362>npm config set https-proxy http://10.89.0.72:84
C:\Users\A702362>npm install -g typescript

Fuente: https://jjasonclark.com/how-to-setup-node-behind-web-proxy/

===============================================================================
Video 003: 003 Arranque de Aplicacion y Estructura de Archivos

Para crear una nueva aplicación (en consola):
ng new appCompras
-------------------------------------
Arrancar el servidor (en consola):
ng serve

Parar el servidor (en consola):
Ctrl+C

Ver el proyecto en navegador: 
localhost:4200
-------------------------------------
Arrancar el servidor en otro puerto (en consola):
ng serve --port 3000

Parar el servidor (en consola):
Ctrl+C

Ver el proyecto en navegador: 
localhost:3000
-------------------------------------
ESTRUCTURA DE ARCHIVOS:
** Fichero index.html
Angular está pensado para hacer aplicaciones en las que el cliente va a ser el navegdor web, por lo tanto, va a tener un archivo index.html en el que se va a renderizar la app (con la etiqueta <app-root></app-root>).

** Fichero favicon.ico
Icono de la página web.

** Fichero styles.css
Estilos css globales para toda la aplicación.

** Fichero package.json
Dependencias, paquetes o librerías de angular que vamos a utilizar en la aplicación y que se instalan en la carpeta node-modules. 

** Directorio src
Donde se va a encontrar los archivos con el código.

** Directorio assets
Los archivos estáticos, especialmente las imágenes.

** Directorio app
Los módulos y componentes de la aplicación. Como está modularizada la aplicación. CLI automáticamente crea unos módulos al inicio. 

===============================================================================
Video 004: 004 Modulos y Componentes en Angular

Todos los módulos tienen que tener al menos un componente.

COMPONENTE: en el fichero typeScript (nombre.component.ts) es donde se define la lógica del componente. Tiene 3 bloques de código: 
** Importaciones: 
Importa paquetes/clases de Angular para hacer la aplicación lo más ligera posible. 
** Decorador: 
@Component: tiene un objeto con 3 metadatos: selector (el componente se va a renderizar en la etiqueta que define 'app-root'), templateUrl (donde está la plantilla html) y styleUrls (donde está la hoja u hojas con los estilos de este componente concreto).
** Exportaciones: 
Exporta la clase del componente (ej. nombreComponent) y en la clase reside la lógica del componente.

MÓDULO:
** Importaciones: 
Importa paquetes/clases de Angular y también importa el componente.
** Decorador: 
@NgModule: tiene un objeto con 3 metadatos: declarations (declaraciones de las clases de los componentes que vamos a utilizar), imports (importa otros módulos) y providers (servicios para utilizarlos en todos los componentes).
-Si es el módulo raíz, el decorador @NgModule tiene otro metadato que es bootstrap, que indica cuál es el componente con el que se va a inicializar el módulo. 
** Exportaciones: 
Exporta la clase del módulo (ej. nombreModule).

El módulo y el componente llegan a index.html porque desde el módulo exportamos la clase del componente, y en el archivo main.ts definimos con  'platformBrowserDynamic().bootstrapModule(nombreModule)' que el módulo va a ser el módulo raíz de la aplicación. 

===============================================================================
Video 006: 006 Creacion de Componentes
Creación de un componente a mano.

===============================================================================
Video 007: 007 Nuevo Componente con Angular CLI

Antes de generar el componente, paramos el servidor desde consola. 

Para generar el componente: 
ng generate component nombrecomponente

Para generar el componente sin archivo spec para los test:
ng generate component copyright --spec false

===============================================================================
Video 008: 008 Componentes Anidados

Para cuando tenemos pocas líneas de código en un componente, podemos hacer una eliminación de ese archivo y poner el código HTML directamente en un metadato del decorador del componente en el fichero typeScript. Cambiamos el metadato "templateUrl: ''" por el metadato "template: `<código HTML>`" (con comillas inclinadas). 

También, podemos anidar componentes introduciendo unos dentro de otros. Se realiza al meter la etiqueta del componente en el metadato "template: `<etiqueta del componente inferior>`" del componente de un nivel superior.

===============================================================================
===============================================================================
TEMA 02 Data Binding
********************

===============================================================================
Video 009: 009 Data Binding_ Introduccion

Data Binding: (unión de datos) en Angular, en los componentes unimos datos entre la plantilla html y la clase del componente que está en el archivo typeScript. 

Hay varias formas:
** One Way Binding: en un sentido, desde la fuente de datos (archivo typeScript) a la vista HTML. Hay 2 fórmulas: Interpolación y Property Binding. 
** One Way Binding: en sentido contrario, desde la vista HTML a la fuente de datos. Tenemos la fórmula: Event Binding.
** Two Way Binding: en ambos sentidos, de la fuente de datos () a la vista HTML y viceversa. Tenemos la fórmula: Two Way Binding.

===============================================================================
Video 010: 010 Interpolacion

Usa la sintaxis "Mustache" de dobles llaves para presentar, de la clase del componente a la plantilla HTML, el valor de una propiedad, el valor de un objeto o una expresión JavaScript. 

1º: creación de una clase constructora de un objeto en angular: a través de un archivo nombre.modelo.ts, que contiene la exportación de la clase, la definición de las propiedades publicas de la clase y el constructor del objeto. Los archivos de clases se crean dentro de la carpeta modelos en la ruta de la ruta src/nombreaplicacion/modelos. 

2º: una vez creado el objeto, vamos a crear un componente:
ng g c nombrecomponente --spec false
(g=generate c=componente)

3º: en el componente, en el fichero typeScript, importamos el objeto y en la clase creamos el objeto. 

4º: en la plantilla HTML del componente metemos un código HTML en el que usamos la interpolación poniendo las propiedades del objeto dentro de las dobles llaves y con la notación del punto nombreobjeto.propiedad)

===============================================================================
Video 011: 011 Interpolacion con Metodos

Utilizar la interpolación para pasar un metodo de la clase del componente a la plantilla del componente.

1º: una vez creado el objeto, vamos a crear un componente:
ng g c nombrecomponente --spec false
(g=generate c=componente)

2º: en la clase del componente creamos una propiedad y la inicializamos. Luego creamos un método metodo(), por ejemplo que devuelva la propiedad creada.

3º: en la plantilla HTML del componente metemos un código HTML en el que usamos la interpolación llamando al método dentro de las dobles llaves {{ metodo() }}.

===============================================================================
Video 012: 012 Property Binding

De la clase del componente a la plantilla. Se aprovecha cualquier atributo que tenga un elemento HTML para asociarlo con una expresión que provenga del componente. Se usan los corchetes en el atributo de HTML y su valor se obtiene del fichero typeScript (tanto de una declaración como de un método).

===============================================================================
Video 013: 013 Event Binding

Manda datos de la plantilla HTML a la clase del componente aprovechando los eventos HTML5. 

Se pone el evento a usar y se iguala a un método que se va a declarar en el componente. 

===============================================================================
Video 014: 014 Two Way Binding

Se pasan los datos en ambos sentidos. 

1º: en la plantilla HTML se usa la sintaxix "Banana box" en las propiedades de un elemento HTML [(directiva)]="propiedaddelaclase".

2º: en la clase del componente se define la propiedad y la directiva es la que se encarga de almacenar la información y pasarla de la clase de la propiedad a la plantilla y viceversa.

3º: hay que fijarse en el módulo nombre.module.ts para comprobar si se ha importado FormsModule:
import { FormsModule } from '@angular/forms';

===============================================================================
===============================================================================
TEMA 03 Directivas
******************

===============================================================================
Video 015: 015 Directivas_ Introduccion

Las directivas son clases Angular con código para crear, formatear e interaccionar con los elementos HMTL en el DOM de las páginas web. 

Hay 3 tipos de directivas:
** Componentes: 
Normalmente no nos referimos a los componentes como directivas.

** Estructurales: 
Son las que alteran el layout o presentación del elemento HTML en el que las introducimos. Se preceden siempre de * (asterisco).
  <elementoHTML *DIRECTIVA="EXPRESION"></elementoHTML>

** De atributos: 
No modifican el layout. Funcionan como un atributo HTML. Van entre corchetes.
  <elementoHTML [DIRECTIVA]="{EXPRESION}"></elementoHTML>

Podemos crear nuestras propias directivas.

===============================================================================
Video 016: 016 ngIf

Es de tipo estructural (modifica el DOM).

ngIf: se mostrará el elemento HTML donde la hemos puesto si se cumple la expresión que tiene a continuación.

  <elementoHTML propiedades="" *ngIf="expresion1"></elementoHTML>

===============================================================================
Video 017: 017 ngIf + else

Es de tipo estructural (modifica el DOM).

ngIf + else: se mostrará el elemento HTML donde la hemos puesto si se cumple la expresión que tiene a continuación el if. Después de la expresión que queremos que se cumpla con ngIg, se pone "; else" y una id. Esa id es una id local de un etiqueta de Angular llamada ng-template. Se define esa etiqueta <ng-template #nombredeidlocal> a continuación del elemento HTML que lleva la directiva y dentro del código de la etiqueda se va a mostrar con el else de la directiva ngIf.  
  <elementoHTML propiedades="" *ngIf="expresion1; else nombredeidlocal">          
  </elementoHTML>
  <ng-template #nombredeidlocal>
    <elementoHTML propiedades=""></elementoHTML>
  </ng-template>

===============================================================================
Video 018: 018 ngIf + else con metodos

Es de tipo estructural (modifica el DOM).

ngIf + else con métodos: se mostrará el elemento HTML donde la hemos puesto si se cumple la expresión que tiene a continuación el if. Después de la expresión que queremos que se cumpla con ngIg, se pone "; else" y una id. Esa id es una id local de un etiqueta de Angular llamada ng-template. Se define esa etiqueta <ng-template #nombredeidlocal> a continuación del elemento HTML que lleva la directiva y dentro del código de la etiqueda se va a mostrar con el else de la directiva ngIf.  

La expresión de los condicionales puede ser la llamada a un método que se definirá en el fichero typeScript del componente.

===============================================================================
Video 019: 019 ngStyle

Es de atributo (no modifica el layout del DOM).

ngStyle: determina el estilo del elemento HTML en función de la expresión que pongamos dentro entre llaves. 

  <elementoHTML [ngStyle]="{EXPRESION}"></elementoHTML>

  <elementoHTML [ngStyle]="{propiedadcss: metodo()}"></elementoHTML>
===============================================================================
Video 020: 020 ngClass

Es de atributo (no modifica el layout del DOM).

ngClass: actúa dinámicamente en las clases de los elementos HTML. Aplica la clase  css que indica entre las llaves cuando la expresión se cumpla. 

  <elementoHTML [ngClass]="{ nombreclasecss: EXPRESION }"></elementoHTML>

===============================================================================
Video 021: 021 ngFor

Es de tipo estructural (modifica el DOM).

ngFor: para iterar arrays, etc. y mostrar tantos elementos HTML como iteraciones se realicen.

  <elementoHTML *ngFor="let variablelocal of array">{{ variablelocal }}          </elementoHTML>

===============================================================================
Video 022: 022 ngFor con objetos

Es de tipo estructural (modifica el DOM).

ngFor con objetos: para iterar objetos. Los objetos se declaran y definen en el fichero typeScript. Por ejemplo, objetos procedentes de una clase que se tenga en el proyecto y que se pueden meter en un array. En la plantilla HTML, se itera el array y se accede a las propiedades de los objetos mediante la notación del punto () 
  <elementoHTML>{{ variablelocal.propiedad }}</elementoHTML>

===============================================================================
Video 023: 023 ngSwitch

Es de atributo (no modifica el layout del DOM).

ngSwitch: asignamos la directiva a una propiedad o variable y dependiendo del valor que ésta tenga, realizará una expresión u otra que se le indique. Por ejemplo, aplicar una clase de CSS. Por cada valor o condición, se crea un elemento HTML asociado a la expresión.

Ejemplo: 
  <li *ngSwitchCase="'valor'" class="clase1">
    <h4>{{ objeto.propiedad }} | {{ objeto.propiedad }}</h4>
  </li>
  <li *ngSwitchCase="'valor'" class="clase2">
    <h4>{{ objeto.propiedad }} | {{ objeto.propiedad }}</h4>
  </li>

===============================================================================
Video 024: 024 Creacion de Directivas Propias

Para crear la directiva se puede utilizar la herramienta de modo de comando de CLI (se crea el fichero nombredirectiva.directive.ts):
ng generate directive nombredirectiva

Para aplicar la directiva:
En la plantilla HTML del componente, en cada elemento HTML en el que se quiera aplicar la directiva, se pone el nombre de la misma que se obtiene en el fichero nombre.directive.ts en el metadato "selector" del decorador @Directive.

La directiva creada automáticamente (y en nombre.module.ts se importa y se declara automáticamente) tiene:
** Importaciones:
Se importa la clase Directive del core de Angular. 
** Decorador:
@Directive: indica el nombre que va a tener la directiva para luego poder implementarla en los componentes.
** Exportaciones: 
Exporta la clase donde va el código que va a realizar la directiva. 

Las directivas propias permiten implementar otras clases y decoradores que proporciona Angular. Estas clases se han de importar en la directiva y se implementan como decoradores (con @) en la clase de la directiva. 
  @ClaseImportada(EXPRESION) 

  Ejemplos:
  @HostBinding('class.clasecss') private propiedad: tipo;

  @HostListener('evento') metodo() {
    //Código del método
  }

Si estamos aplicando una clase CSS, como la idea es que se pueda usar en toda la aplicación, se incluirá en el fichero src/styles.css

===============================================================================
Video 025: 025 Datos entre Componentes_ @Input

Para pasar PROPIEDADES entre componentes.

Si queremos que una propiedad de una clase en un componente hijo reciba el valor de otro componente padre:

1º: en el componente hijo, en el fichero typeScript se importa la clase Input del core de Angular y en la clase del componente en la declaración de la propiedad se usa el decorador @Input(). En la plantilla HTML se hace referencia por interpolación a esa propiedad. 

En hijo.component.ts:
  export class HijoComponent implements OnInit {
    @Input() propiedadHijo: tipo;
  }

En hijo.component.html:
  <elementoHTML>{{ propiedadHijo }}</elementoHTML>

2º: en el componente padre, en el fichero typeScript se declara la propiedad cuyo valor se va a pasar al componente hijo. En la plantilla HTML, se incorpora la etiqueta que anida el componente hijo <app-hijo> y en esa etiqueta se pone el nombre de la propiedad en el hijo entre corchetes asociado al nombre de la propiedad del componente padre.

En padre.component.ts:
  export class PadreComponent implements OnInit {
    propiedadPadre: tipo = 'Valor que se va a inyectar del padre al hijo';
  }

En padre.component.html:
  <elementoHTML class="padre">
      <app-hijo [propiedadHijo]="propiedadPadre"></app-hijo>
  </elementoHTML>
-------------------------------------------------------------------------------
En el caso de un array:

En Angular tiene bastante utilidad cuando queremos de un array disponer de un componente generalista donde estén todos los elementos que sería el padre y de un componente hijo donde se tendrían los detalles. 

En hijo.component.ts (no hay cambios):
  export class HijoComponent implements OnInit {
    @Input() propiedadHijo: tipo;
  }

En hijo.component.html (no hay cambios):
  <elementoHTML>{{ propiedadHijo }}</elementoHTML>

En padre.component.ts:
  export class PadreComponent implements OnInit {
    arrayEnPadre: tipo[] = ['valor 1', 'valor 2', 'valor 3'];
  }

En padre.component.html:
  <elementoHTML class="padre">
    <app-hijo *ngFor="let variablelocal of arrayEnPadre" 	[propiedadHijo]="variablelocal"></app-hijo>
  </elementoHTML>

===============================================================================
Video 026: 026 Datos entre Componentes_ @Output

Para pasar MÉTODOS entre componentes.

Si queremos pasar el valor de una propiedad de un componente hijo mdiante métodos a una propiedad del componente padre:

1º: en el componente hijo, en el fichero typeScript se importa la clase Output del core de Angular (y otras clases que se necesiten como EventEmitter) y en la clase del componente en la declaración de la propiedad se usa el decorador @Output(). En la plantilla HTML se hace al método. 

En hijo.component.ts:
  export class HijoComponent implements OnInit {
    @Output() propiedadHijo = new EventEmitter();

    metodoHijo() {
      // Código donde se hace referencia a la propiedadHijo
      // En la propiedadHijo se emite lo que hya en el código
      propiedadHijo.emit(codigo);
    }
  }
o 
  export class HijoComponent implements OnInit {
    @Output() propiedadHijo: tipo;
    
    metodoHijo() {
      // Código donde se hace referencia a la propiedadHijo
      // En la propiedadHijo se emite lo que hya en el códigog
      propiedadHijo.emit(codigo);
    }
  }

En hijo.component.html:
  <elementoHTML (evento)="metodoHijo()"></elementoHTML>

2º: en el componente padre, en el fichero typeScript se define el método del padre y recoge el evento (por ejemplo, dentro de una propiedadPadre). En la plantilla HTML, se incorpora la etiqueta que anida el componente hijo <app-hijo> y en esa etiqueta se pone el nombre de la propiedad en el hijo entre paréntésis asociado al nombre del método del componente padre y fuera de la etiqueta del hijo, se pone un elemento HTML que recoja la propiedad en el padre.

En padre.component.ts:
  export class PadreComponent implements OnInit {
    propiedadPadre: tipo;

    metodoPadre(event) {
      propiedadPadre = event;
    }
  }

En padre.component.html:
  <elementoHTML class="padre">
      <app-hijo (propiedadHijo)="metodoPadre()"></app-hijo>
  </elementoHTML>

En la plantilla HTML, cuando un evento tiene varios métodos, éstos se separan por punto y coma:
  <elementoHTML (evento)="metodo1(); metodo2()"></elementoHTML>

En la plantilla HTML, cuando un evento tiene un método que tiene que recibir el evento como parámetro se escribe entre el paréntesis (metodo($event))
  <elementoHTML (evento)="metodo($event)"></elementoHTML>

===============================================================================
===============================================================================
TEMA 04 Pipes
*************

Los pipes se emplean para dar formato de salida a los valores que se emplean en la aplicación.

===============================================================================
Video 027: 027 Pipe Date

Pipe Date: para dar formato a fechas (hora y uso horario). El nombre del pipe es 'date'.

Ejemplos:
  <p>Madrid, {{ hoy | date: 'd/M/y H:m' }}</p>
  SALIDA: Madrid, 14/8/2019 13:36
  <p>Madrid, {{ hoy | date: 'd-M-y' }} a las {{hoy | date: 'H:m Z'}}</p>
  SALIDA: Madrid, 14-8-2019 a las 13:36 +0200

===============================================================================
Video 028: 028 Pipe Uppercase y Lowercase

Pipe Uppercase: modifica las cadenas de texto a mayúsculas. El nombre del pipe es 'uppercase'.

Pipe Lowercase: modifica las cadenas de texto a minúsculas. El nombre del pipe es 'lowercase'.

Ejemplos:
  Siendo ciudad tipo string = Madrid:
    <p> {{ ciudad | uppercase }} es mi ciudad</p>
    SALIDA: MADRID es mi ciudad
    <p> {{ ciudad | lowercase }} es mi ciudad</p>
    SALIDA: madrid es mi ciudad

===============================================================================
Video 029: 029 Pipe Decimal

En javaScript para los decimales se utiliza el punto. 

Pipe Decimal: para formatear números. El nombre del pipe es 'number'. Las opciones indican: dígitos enteros que va a tener la presentación del número.número mínimo de dígitos decimales-número máximo de dígitos decimales

Ejemplos:
  Siendo resultado tipo number = 1.148:
    <p>El resultado es {{ resultado | number: '3.2-2' }}</p>
    SALIDA: El resultado es 001.15
  Siendo resultado tipo number = 1.2:
    <p>El resultado es {{ resultado | number: '3.2-2' }}</p>
    SALIDA: El resultado es 001.20

===============================================================================
Video 030: 030 Pipe Currency

Pipe Currency: para utilizar con monedas. El nombre del pipe es 'currency'. Las opciones indican: 'código de la moneda': true (para que se muestre el símbolo de la moneda).

Ejemplos:
  Siendo dolareuro tipo number = 0.88;
    <p>El cambio del dólar es de {{ dolareuro | currency: 'EUR': true }}</p>
    SALIDA: El cambio del dólar es de €0.88
    <p>El cambio del dólar es de {{ dolareuro | currency: 'EUR': false }}</p>
    SALIDA: El cambio del dólar es de EUR0.88

===============================================================================
Video 031: 031 Pipe i18nSelect

Pipe i18nSelect: para establecer el valor de una propiedad en función del valor de otra. 
En nombre.component.ts:
  export class EjpipesComponent implements OnInit {
    propIndependiente : tipo = 'valor1Indep';
    propDependiente: any = {'valor1Indep':'valor1Dep', 'valor2Indep':'valor2Dep'};
    }

En nombre.component.html:
  <p>{{ propiedadIndependiente | i18nSelect: propiedadDependiente }}</p>

Ejemplos:
  En nombre.component.ts:
    export class EjpipesComponent implements OnInit {
      nombre1: string = 'Laura';
      sexo1: string = 'mujer';
      nombre2: string = 'Pedro';
      sexo2: string = 'hombre';
      encabezamiento: any = {'hombre':'Estimado', 'mujer':'Estimada'};
    }
  En nombre.component.html:
    <p>{{ sexo1 | i18nSelect: encabezamiento }} {{ nombre1 }}</p>
  SALIDA: Estimada Laura
  En nombre.component.html:
    <p>{{ sexo2 | i18nSelect: encabezamiento }} {{ nombre2 }}</p>
  SALIDA: Estimado Pedro

===============================================================================
Video 032: 032 Creacion de Pipes Propios

Para crear un pipe se puede utilizar la herramienta de modo de comando de CLI (se crea el fichero nombrepipe.pipe.ts):
ng generate pipe nombrepipe

El pipe creado automáticamente (y en nombre.module.ts se importa y se declara automáticamente) tiene:
** Importaciones:
Se importa las dependencias y librerías que necesita para trabajar. Importa Pipe y PipeTransform del core de Angular. 
** Decorador:
@Pipe: indica el nombre que va a tener el pipe para luego poder usarlo. 
** Exportaciones: 
Exporta la clase donde va el código que va a realizar el pipe. La clase implementa la interfaz PipeTransform que nos da un método transform() que modificaremos para obtener la funcionalidad que se desee que realice el pipe:
  transform(value: any, ...args: any[]): any {
    return null;
  }

Para aplicar el pipe se pone su nombre de la misma forma que el resto de pipes. 

===============================================================================
===============================================================================
TEMA 05 Servicios
*****************

===============================================================================
Video 033: 033 Creacion de un Servicio

Los servicios son unos elementos de angular que nos permiten centralizar el código para luego emplearlo en cada componente donde lo necesitemos mediante la inyección de dependencias. Se llaman 'providers' porque se usan para gestionar datos e inyectarlos en los componentes.

Los proyectos suelen tener varios servicios así que lo mejor es reunirlos en un directorio. 

Para crear un servicio se puede utilizar la herramienta de modo de comando de CLI (se crea el fichero nombreservicio.service.ts):
ng generate service nombrecarpeta/nombreservicio --spec false

Cuando se crea puede estar generado pero no provisto, por lo tanto, hay que introducirlo en el archivo app.module.ts importándolo desde la carpeta donde se ha guardado y metiéndolo en el metadato "providers" del decorador @NgModule. 

El archivo del servicio tiene una estructura de código compuesta por: 
** Importaciones:
Se importa la clase Inyectable del core de Angular. 
** Decorador:
@Injectable.
** Exportaciones: 
Exporta la clase donde va el código que va a realizar el sercivio.

Angular implementa un servicio en un componente mediante métodos, para trasladar el código de los servicios a los componentes. La forma de hacerlo es: 

1º: en el fichero typeScript del componente, importando el servicio y en el constructor de la clase usando como parámetro una propiedad nombreservicio e igualándola al nombre de la clase del servicio. Al estar en el constructor, cuando se inicie el componente se va a llamar a ese servicio. El nombre de la propiedad puede ir con letra minúscula, o poniendo delante un guión bajo o poniendo pService.

Ejemplo:
  constructor(private proveedoresService: ProveedoresService) { }
  constructor(private _proveedoresService: ProveedoresService) { }
  constructor(private pService: ProveedoresService) { }

2º: desde el fichero typeScript del componente se llama al método del servicio usando el método ngOnInit() cuya función es que cada vez que se inicialice dentro del ciclo de vida de los componentes angular este componente, llevará a cabo el código que lleva dentro. 

===============================================================================
Video 034: 034 Objetos en Servicios

En el servicio, en la clase, puede haber un array que contenga un conjunto de objetos. Ese array puede ser devuelto por un método dentro de la clase.

  export class nombreservicioService {
    nombreArray: any = [{ objeto1 }, { objeto2 }];
    constructor() { }
    metodoDelServicio() {
      return this.nombreArray; // Devuelve el array
    }

En el componente, desde el método ngOnInit() se llama al método del servicio y se obtiene el valor de los objetos. 

===============================================================================
===============================================================================
TEMA 06 Routing
***************

===============================================================================
Video 035: 035 Implementacion de Routing

Las aplicaciones angular están diseñadas para ser Single Page Application (SPA), con lo que van a contar con una página sobre la cual los componentes se van a ir renderizando sin necesidad de que refresque la página, coniguiendo una aplicación ágil y eficiente. 

Esto no significa que todos los componentes estén en una misma y única página puesto que haría que fuera una aplicación compleja y difícil de manejar por el usuario cuando hay muchos componentes. Para ello se emplea el Routing.

El Routing con la ayuda de la barra de navegación del navegador establece una serie de URL que cargan dinámicamente cada componente. 

A) En el módulo de la aplicación (app.module.ts): 
1º: se importan los paquetes de Routing que son Routes y RouterModule desde @angular/router.

2º: en los imports del decorador @NgModule se importa RouterModule.forRoot(routes) para establecer un array de rutas que va a usar la aplicación para cargar los distintos componentes en la página. 

3º: se crea como una constante el array de rutas. La primera ruta va sin nombre del componente porque va a coincidir con la URL raíz de la aplicación:
  const routes: Routes = [
    { path: '', component: InicioComponent },
    { path: 'nombreruta', component: NombrecomponenteComponent }
  ];

También se puede añadir una ruta con una máscara para que cuando escribamos una ruta que no existe nos derive a ella (ejemplo de la página para error 404): 
    { path: '**', component: NombrecomponenteAlQueDerivar }

B) En la plantilla raíz (app.component.html) de la aplicación se pone la etiqueta de angular <router-outlet> que dinámicamente estable la etiqueta del componente que le diga la ruta. 

===============================================================================
Video 036: 036 Barra de Navegacion

Para crear una barra de navegación con links a las rutas que hemos establecido para el Routing: 

1º: se crea un componente  (por ejemplo lo llamamos header). En la plantilla del componente ponemos una barra de navegación (de bootstrap4 o se crea manualmente o se saca de otro framework). Se personalizan los links con las url de la aplicación: 

  <li class="nav-item" routerLinkActive="active">
      <a class="nav-link" routerLink="/">Inicio </a>
  </li>
  <li class="nav-item" routerLinkActive="active">
      <a class="nav-link" routerLink="/nombreruta">Nombre página</a>
  </li>

2º: En la plantilla raíz (app.component.html) de la aplicación se pone la etiqueta con el nombre del componente que tiene la barra de navegación. 
Ejemplo de app.component.html:
  <app-header></app-header>
  <div class="container">
    <router-outlet></router-outlet>
  </div>  

===============================================================================
===============================================================================
TEMA 07 Formularios
*******************

===============================================================================
Video 037: 037 Template Driven

Los formularios es la parte de la web don de el usuario va a interaccionar introduciendo datos y por ello, son muy importantes. 

Hay dos modalidades para crear formularios en Angular:
** Template Driven: realiza la lógica de captura de datos como la validación de los mismos del lado del archivo HTML. 
** Reactive: gestiona el formulario desde el archivo typeScript.

Ejemplo: creamos un nuevo componente con un formulario. Este componente se incluye en el array de rutas de app.module.ts y se enlaza con algún link en la barra de navegación o algún link de botón. 

===============================================================================
Video 038: 038 Template Driven II

A partir del ejemplo que tenemos, vamos a añadir la lógica. 

1º: antes de empezar, hay que asegurarse que en la aplicación se tiene importado FormsModule que es la librería para gestionar formularios (en app.module.ts):
  import { FormsModule } from '@angular/forms';

2º: en el fichero typeScript del componente que tiene el formulario, en la clase, se declara un objeto en el que se guardarán los datos del formulario y en el constructor se inicializa ese objeto en forma de documento json con sus propiedades con los valores de texto vacíos y los numéricos a null.

3º: se enlazan los datos del formulario con la clase del componente.
1) En la plantilla HTML del componente que tiene el formulario, en la etiqueta del formulario <form> se añade la clase (ngSubmit) de FormsModule y se iguala a un método nuestro para que cuando se le dé al botón Submit angular desencadene el método.
2) En la plantilla HTML del componente que tiene el formulario, también en la etiqueta <form> se identifica el formulario con un id local #formpro="nombreFormulario" para que el objeto que se crea con el formulario (gracias a la importación de la clase FormsModule) tenga esa id local.
3) En la plantilla HTML del componente que tiene el formulario, por último, hay que identificar cada uno de los campos en el objeto del formulario. Dentro de la etiqueta input en cada campo se añade ngModel name="nombrepropiedadobjeto". 

4º: en el fichero typeScript del componente que tiene el formulario, se importa ViewChild del core de Angular y NgForm de los formularios de Angular:
import { ViewChild } from '@angular/core';
import { NgForm } from '@angular/forms';
Dentro de la clase, en modo decorador se añade @ViewChild para hacer una vista del id local del formulario y el nombre de la vista se declara del tipo NgForm. 

5º: el método que se llama a través de (ngSubmit) se declara en la clase en el fichero typeScript del componente que tiene el formulario. En este método se enlaza la propiedad del objeto con el valor de la propiedad del objeto del formulario asociado a esa propiedad.

Si no se tiene una base de datos, pero se quiere comprobar si el objeto se está cargando correctamente en el formulario y en el método, se puede usar en la plantilla HTML del componente que se muestre el objeto por interpolación usando el pipe 'json'.
  <pre>{{ proveedor | json }}</pre>

===============================================================================
Video 039: 039 Carga de Datos en Select

En los formularios los campos de tipo Select son campos con valores fijos de los cuales el usuario tiene que escoger uno de ellos. 

En el fichero typeScript del componente que tiene el formulario, se añade un array con los valores que el usuario tendrá para elegir en el campo Select. 

En la plantilla HTML del componente que tiene el formulario, en el campo que queremos que sea Select ponemos la etiqueta <select> e identificamos con la misma propiedad en el objeto del formulario. También se añade ngModel name="nombrepropiedadobjeto". En las opciones iteramos el array con la directiva *ngFor.

===============================================================================
Video 040: 040 Validaciones HTML

Validaciones de HTML5. Algunas son: required (campo obligatorio), email (el texto cumple con las reglas de un email), etc.

Angular anula las validaciones de HTML5 porque ngForm tiene su propio sistema de validación. Implementa una serie de estados por los que pasa el campo cuando el usuario está utilizando el formulario. Los estados son:
** Dirty: cuando el usuario comienza a utilizar el campo (pulsar sobre el campo y empezar a escribir) es true.
** Pristine: cuando el campo aún no se ha tocado es true.
** Touched: cuando se quita el foco del campo pasa a true
** Valid: el campo cumple con las normas de validación que tiene puestas.
** Invalid: el campo no cumple con las normas de validación que tiene puestas.

Angular tiene asociadas a estos estados una serie de clases CSS que nos permiten configurar las ayudas al usuario a la hora de completar el formulario. También como son propiedades del objeto se pueden utilizar para establecer una lógica en el botón de envío. La forma de enlazar desde el fichero CSS del componente que tiene el formulario es, por ejemplo:
  input.ng-invalid.ng-touched {
    border-left: 5px solid #A94442;
  }
  input.ng-valid.ng-dirty {
    border-left: 5px solid #42A948;
  }

===============================================================================
Video 041: 041 Ayudas Dinamicas

Se pueden añadir mensajes/iconos para que aparezcan en función del estado del campo.

Iconos:
En la plantilla HTML del componente que tiene el formulario, en la etiqueta input hay que poner un id local para identificarlo: 
  #idlocal="ngModel">
Se pueden añadir iconos en los cuales se usa la directiva *ngIf y la condición sea  si el campo cumple un estado u otro: 
   <i class="fa fa-check-circle check" *ngIf="idlocal.valid"></i>
   <i class="fa fa-exclamation-circle uncheck" *ngIf="idlocal.invalid &&         idlocal.touched"></i>

En el ejemplo se han usado iconos de fontawesome (fa=fontawesome) así que se ha de importar al index.html:
  <script src="https://use.fontawesome.com/bacad173cf.js"></script>
 
Mensajes con textos:
Se añade un párrafo en el cual se usa la directiva *ngIf siendo la condición que el campo cumpla un estado u otro:
  <p class="alert alert-danger" *ngIf="idlocal.invalid && idlocal.touched">
            Por favor, introduzca una dirección de correo válida
  </p>

Se puede añadir el atributo "Disable" al botón del submit para que solo se pueda enviar cuando la totalidad del formulario sea válida. 
  <button type="submit" class="btn btn-success"
          [disabled]="!formpro.valid">
          Añadir Proveedor
  </button>

===============================================================================
Video 042: 042 Reactive

Hay dos modalidades para crear formularios en Angular:
** Template Driven: realiza la lógica de captura de datos como la validación de los mismos del lado del archivo HTML. 
** Reactive: gestiona el formulario desde el archivo typeScript.

Reactive tiene aún más control sobre la gestión de los formularios. 
 
En app.module.ts hay que importar la dependencia ReactiveFormsModule desde los formularios de Angular. 
  import { ReactiveFormsModule } from '@angular/forms';

Ejemplo: creamos un nuevo componente con un formulario. Este componente se incluye en el array de rutas de app.module.ts y se enlaza con un link en la barra de navegación.

===============================================================================
Video 043: 043 Reactive II

A partir del ejemplo que tenemos, vamos a añadir la lógica. 

1º: antes de empezar, hay que asegurarse que en la aplicación se tiene importado ReactiveFormsModule que es la librería para gestionar formularios con la técnica Reactive (en app.module.ts):
  import { ReactiveFormsModule } from '@angular/forms';

2º: en el fichero typeScript del componente que tiene el formulario, se importa FormControl, FormGroup y FormBuilder de los formularios de Angular:
  import { FormControl, FormGroup, FormBuilder } from '@angular/forms';

3º: en el fichero typeScript del componente que tiene el formulario, en la clase: 
1) Se declara un objeto en el que se almacenarán los valores de los campos del formulario y es de la clase FormGroup (ej: objeto1). 
2) También se declara otro objeto de este componente donde se van a almacenar con formato json los valores de cada nuevo presupuesto (ej: objeto2).  
3) En el constructor, como parámetro se pone una nueva propiedad de la clase FormBuilder (ej: propCompo1).
4) En el método ngOnInit(), se iguala el objeto de la clase FormGroup con el método de la propiedad de la clase FormBuilder, en concreto con el método group()  que sirve para asociar los diferentes campos, inicializando vacías dentro del método el objeto del componente cada una de sus propiedades:
  ngOnInit() {
    this.objeto1 = this.propCompo1.group({
      propiedad1: '',
      propiedad2: ''
    });
  }

4º: se enlazan los datos del formulario con la clase del componente.
1) En la plantilla HTML del componente que tiene el formulario, en la etiqueta del formulario <form> se añade [formGroup] y se iguala al objeto del formulario (ej: el objeto1).
2) En la plantilla HTML del componente que tiene el formulario, hay que identificar cada uno de los campos en el objeto del formulario. Dentro de la etiqueta input en cada campo se añade formControlName="nombrepropiedadobjeto".

Si en este momento, se meten datos en los campos del formulario quedan reflejados en tiempo real en el objeto del formulario sin necesidad aún de haberlos enviado. 

5º: ahora hay que aplicar la lógia al botón de envío. 
1) En la plantilla HTML del componente que tiene el formulario, en la etiqueta del formulario <form> se añade la clase (ngSubmit) y se iguala a un método nuestro para que cuando se le dé al botón Submit angular desencadene el método.
2) El método que se llama a través de (ngSubmit) se declara en la clase en el fichero typeScript del componente que tiene el formulario. En este método se enlaza cada propiedad del objeto del componente con otro método nuevo.
3) El método nuevo crea una constante en forma de objeto de tipo json en memoria con las mismas propiedades del objeto del componente y cada propiedad va a tener el valor de cada propiedad del objeto del formulario para el mismo nombre. El método devuelve la constante. 
 onSubmit() {
    this.objeto2 = this.newMetodo();
  }
  newMetodo() {
    const nuevoMetodo = {
      propiedad1: this.objeto1.get('propiedad1').value,
      propiedad2: this.objeto1.get('propiedad2').value
    };
    return nuevoMetodo;
  }

Si no se tiene una base de datos, pero se quiere comprobar si los objetos se están cargando correctamente en el formulario y en el método, también ver el estado del objeto del formulario, se puede usar en la plantilla HTML del componente que se muestre el objeto por interpolación usando el pipe 'json'.
  <pre>Valor obj del formulario: {{ objeto1.value | json }}</pre>
  <pre>Estado obj del formulario: {{ objeto1.status | json }}</pre>
  <pre>Valor objeto del componente: {{ objeto2.value | json }}</pre>

===============================================================================
Video 044: 044 Validacion Programatica

No se usan las validaciones de HTML5.

La validación programática se hace por parte del componente. 

1º: en el fichero typeScript del componente que tiene el formulario se importa la clase Validators desde los formularios de Angular. 
  import { Validators } from '@angular/forms';

La clase Validators se añade al objeto del formulario (en el ej. objeto1), en cada una de las propiedades del objeto que se quiera validar, en el método ngOnInit() cuando se está inicializando el objeto. Si se tienen varias validaciones sobre un mismo campo, se introducen en un array de validaciones. Ejemplo: validación de "requerido":
  ngOnInit() {
    this.objeto1 = this.propCompo1.group({
      propiedad1: ['', Validators.required ],
      propiedad2: ['', [Validators.validacion1, Validators.validacion2] ]
    });
  }

2º: en la plantilla HTML del componente que tiene el formulario, se puede añadir el atributo "Disable" al botón del submit para que solo se pueda enviar cuando la totalidad del formulario sea válida. 
  <button type="submit" class="btn btn-success"
          [disabled]="!objeto1.valid">
          Añadir Presupuesto
  </button>

3º: se puede añadir un párrafo en el cual se usa la directiva *ngIf siendo la condición que el campo cumpla un estado u otro:
  <p class="alert alert-danger" *ngIf="objeto1.invalid && objeto1.touched">
            Por favor, complete todos los campos obligatorios
  </p>

Angular tiene asociadas a los estados una serie de clases CSS que nos permiten configurar las ayudas al usuario a la hora de completar el formulario. También como son propiedades del objeto se pueden utilizar para establecer una lógica en el botón de envío. La forma de enlazar desde el fichero CSS del componente que tiene el formulario es, por ejemplo:
  input.ng-invalid.ng-touched {
    border-left: 5px solid #A94442;
  }
  input.ng-valid.ng-dirty {
    border-left: 5px solid #42A948;
  }

Si se quiere añadir mensajes de alerta, iconos o ayudas al usuario, se hace igual que en el video "Ayudas Dinamicas":         
  <i class="fa fa-check-circle check"
     *ngIf="objeto1.controls.proveedor.valid"></i>
  <i class="fa fa-exclamation-circle uncheck"
     *ngIf="objeto1.controls.proveedor.invalid &&
            objeto1.controls.proveedor.touched"></i>
  <p class="alert alert-danger"
     *ngIf="objeto1.controls.proveedor.invalid &&
            objeto1.controls.proveedor.touched">
              El campo proveedor es obligatorio
  </p>

En la web https://angular.io/api/forms/Validators se encuentra la documentación con las diferentes opciones de validación que se pueden usar:
class Validators {
  static min(min: number): ValidatorFn
  static max(max: number): ValidatorFn
  static required(control: AbstractControl): ValidationErrors | null
  static requiredTrue(control: AbstractControl): ValidationErrors | null
  static email(control: AbstractControl): ValidationErrors | null
  static minLength(minLength: number): ValidatorFn
  static maxLength(maxLength: number): ValidatorFn
  static pattern(pattern: string | RegExp): ValidatorFn
  static nullValidator(control: AbstractControl): ValidationErrors | null
  static compose(validators: ValidatorFn[]): ValidatorFn | null
  static composeAsync(validators: AsyncValidatorFn[]): AsyncValidatorFn | null
}

===============================================================================
Video 045: 045 valueChanges

ValueChanges permite crear formularios dinámicos, por ejmplo, operaciones aritméticas entre camposa tiempo real. 

En el fichero typeScript del componente que tiene el formulario, en la clase: 
1) Se declaran tantas nuevas propiedades como campos del formulario intervengan en las operaciones aritméticas. Algunas se inicializan a cero. 
  propiedad3: any;
  propiedad4: any = 0;
2) En la inicialización en ngOnInit(), ahora esas propiedades del objeto del formulario no se van a inicializar vacías sino que se inicializan igualándolas a las nuevas propiedades de la clase (cada propiedad de la calse respecto a su propiedad del objeto correspondiente). También se llama a un método nuevo onChanges().
  ngOnInit() {
    this.objeto1 = this.propCompo1.group({
      propiedad1: ['', Validators.required ],
      propiedad4: this.propiedad4
    });
    this.onChanges();
  }
3) Se define el método de tipo void para que se detecten los cambios a tiempo real. Para el objeto del formulario bajo a la clase observable valueChanges y el método subscribe() y una función flecha en la que por un lado se iguale la propiedad de la clase valor del campo de esa propiedad a tiempo real y por otro, se hagan marquen las operaciones. 
  onChanges(): void {
    this.objeto1.valueChanges.subscribe(valor => {
      this.propiedad3 = valor.propiedad3;
      this.objeto1.value.propiedad4 = this.propiedad3 * 2;
    })


En la plantilla HTML del componente que tiene el formulario, se ha de establecer ngModel para que se actualicen en tiempo real los valores de las propiedades en las que se realizan los cálculos. En el campo del fomulario que se va a actualizar en tiempo real:
  <input type="number" class="form-control" 
         id="propiedad4" formControlName="propiedad4"
         [(ngModel)]="objeto1.value.propiedad4">



Se obtienen formularios interactivos que realizan operaciones aritméticas.

Los campos que reciben los cálculos se pueden deshabilitar para que el usuario no los modifique a mano. 

===============================================================================
===============================================================================
TEMA 08 HTTP_ Base de datos en Firebase
***************************************

===============================================================================
Video 046: 046 Configuracion de Firebase

Firebase es una base de datos persistente en la nube.

Vamos a emplear los métodos HTTP para conseguir que la aplicación sea de tipo CRUD (Create, Read, Update y Delete) en tiempo real. Los métodos HTTP son habitualmente utilizados en las aplicaciones web. 

Desde google, logueados con una cuenta google, escribimos firebase.google.com y en la web entramos en "IR A LA CONSOLA" (https://console.firebase.google.com/).

Añadimos proyecto, le damos un nombre y lo creamos. Una vez en el proyecto, entramos en Database (Menú lateral - Desarrollo - Database), y creamos una base de datos "Realtime Database".

En la consola de la BBDD, en la pestaña REGLAS, modificamos la regla que viene por defecto y que es para solicitar autentificación y ponemos lo siguiente para que no sea necesario autentificarse: 
  {
    "rules": {
     ".read": "true",
      ".write": "true"
    }
  }

En la pestaña DATOS aparece una URL que es la que se utiliza para conectarse con la BBDD mediante peticiones HTTP: https://nombrebbdd-800ac.firebaseio.com/

Firebase dispone de una API propia de comunicación para conectarse con las aplicaciones Angular, pero no vamos a usarla para aprender cómo se usan las peticiones HTTP en Angular tanto para Firebase como para otro tipo de servidores de BBDD que no sean Firebase. 

===============================================================================
Video 047: 047 HTTP Post_ Crear Registros_

Crear registros en la BBDD con la petición post. 

Se crea un nuevo servicio de Angular y se importa al módulo (app.module.ts). En app.module.ts se importan las dependencias para HTTP: 
import { HttpModule } from '@angular/http';

En el fichero del servicio se implementa la petición post para que cuando se cree un registro de un objeto de la clase se envíe a la BBDD Firebase:
1º: se importan las clases necesarias y la librería 'rxjs' para emplear Post:
  import { Headers, Http, Response } from '@angular/http';
  import 'rxjs/Rx';
2º: en la clase creamos una variable para almacenar la url de la colección de documentos (tabla) de la base de datos. A la url que proporciona Firebase se añade el nombre de la tabla con la extensión json. 
  variable = 'https://nombrebbdd-800ac.firebaseio.com/tabla1.json';
3º: en la clase, en el constructor como parámetro pasamos un objeto de la clase Http de Angular.
4º: se crea el método para insertar objetos en la base de datos que recibe por parámetro un objeto (lo recibe del componente que tiene el formulario de creación de un objeto). Se crea una constante para transformar en cadena el parámentro que recibe el método. Se crea otra constante de la clase Headers para las cabeceras. Este método va a devolver la respuesta del servidor y se tiene el enlace entre nuestro servicio y la base de datos.

En el fichero typeScript del componente que tiene el formulario de creación del objeto que se va a guardar en la base de datos se implementa el servicio: 
1º: se importa el servicio. 
2º: en el constructor se introduce como parámetro. 
3º: en el método onSubmit(), se envía el objeto con los valores del formulario al método post del servicio para que lo reciba como parámetro. 

===============================================================================
Video 048: 048 HTTP Get_ Leer Registros_

Recuperar registros de la BBDD (operaciones de lectura) con la petición get. 

En el fichero del servicio se implementa la petición get para poder leer los registros de la BBDD Firebase:
1º: se crea un método sin parámetros que devuelve lo que está en la url en formato json.

Se crea un componente en la aplicación para recuperar y listar los resultados. Se añade su ruta al array de rutas del app.module.ts. 

En la plantilla HTML del componente, se crea una tabla para recibir los resultados y un botón para acceder a la plantilla del componente para añadir nuevos registros.  

En el fichero typeScript del componente:
1º: se importa el Servicio.
2º: en la clase se define el array de objetos y se inicializa vacío.
3º: en el constructor se implementa el Servicio en el componente como parámetro. 
4º: en el constructor, se cargan los registros de la base de datos en el componente, llamando al método del Servicio (que los ha formateado a formato json). Como en la BBDD Firebase hay una estructura de organización en la cual cada registro tiene un id para el nodo y el conjunto de propiedades, hay que introducir un for para recorrer la tabla y pasarlo a nuestra estructura de objetos de la aplicación. 

===============================================================================
Video 049: 049 HTTP Put_ Actualizar Registros I

Actualizar o editar registros de la BBDD con la petición put. 

En el fichero del servicio se implementa la petición put para que cuando se actualicen los registros en la BBDD Firebase:
1º: en la clase creamos una variable para almacenar la url de la colección de documentos (tabla) de la base de datos. A la url que proporciona Firebase se añade el nombre de la tabla sin la extensión json. 
  variable = 'https://nombrebbdd-800ac.firebaseio.com/tabla1';
2º: se añade un método para antes de actualizar un registro, recuperarlo y que recibe como parámetro el identificador de Firebase. Se crea una constante para cargar una nueva url para el objeto y obtenerlo en formato json. El método devuelve la respuesta del servidor en formato json. 
3º: se crea un método para implementar realizar la actualización. El método recibe como parámetros el objeto a actualizar y su id. Se crea una constante que será la actualización del objeto que viene del componente. Se crea otra constante de la clase Headers para las cabeceras. Se crea la constante de la ruta para acceder al registro correspondiente. El método devuelve el presupuesto actualizado en formato json.

Se crea un componente en la aplicación para recuperar y editar los resultados. Se añade su ruta al array de rutas del app.module.ts. Se puede poner un formulario y a los campos input se les añade ngModel para actualizar los datos con los datos del objeto (excepto los campos que puedan tener operaciones aritméticas). 

===============================================================================
Video 050: 050 HTTP Put_ Actualizar Registros II

En el fichero typeScript del componente que tiene el formulario de edición del objeto que se va a guardar en la base de datos se implementa el servicio: 
1º: se importa el Servicio y se importa FormControl, FormGroup y FormBuilder de los formularios de Angular:
  import { FormControl, FormGroup, FormBuilder } from '@angular/forms';
2º: en la clase: 
1) Se declara un objeto en el que se almacenarán los valores de los campos del formulario y es de la clase FormGroup (ej: objeto1). 
2) También se declara otro objeto de este componente donde se van a almacenar con formato json los valores de cada nuevo presupuesto (ej: objeto2). 
3) Se declaran tantas nuevas propiedades como campos del formulario intervengan en las operaciones aritméticas. Algunas se inicializan a cero. 
4) En el constructor, como parámetro se pone una nueva propiedad de la clase FormBuilder (ej: propCompo1) y otro parámetro para implemntar el Servicio en el componente.
5) En el método ngOnInit(), se iguala el objeto de la clase FormGroup con el método de la propiedad de la clase FormBuilder, en concreto con el método group()  que sirve para asociar los diferentes campos, inicializando vacías dentro del método el objeto del componente cada una de sus propiedades:
  ngOnInit() {
    this.objeto1 = this.propCompo1.group({
      propiedad1: '',
      propiedad2: ''
    });
  }
También se incluyen los métodos necesarios si se tienen operaciones aritméticas o campos bajo valueChanges (campos calculados a partir de otros que se actualizan en tiempo real, etc).
6) En el método onSubmit() se envía el objeto con los valores del formulario al método put del servicio para que lo reciba como parámetro y también se envía a ese método el id del registro. En Angular, esa id se obtiene de la ruta de navegación en la que está contenida. Para ello se importan las clases Router y ActivatedRoute de la clase router de Angular y en el constructor se incluyen como parámetros dos variables, una de cada clase. En el constructor se para que se inicialice con el componente se añade un código para recuperar de la base de datos un registro concreto completo (incluido el id que le da Firebase) y volcarlo en una propiedad de la clase del componente y como se aplica ngModel, esos campos se presentarán en los campos del formulario. El usuario editará los campos y se guardarán en la base de datos.

Para conseguir establecer la ruta específica que contiene el id del componente para llegar a ese componente: se modifica la ruta de la web de edición del array de path de app.module.ts, añadiendo :id para forzar el tener que introducir /id. Creamos un botón para poder establecer esta nueva ruta desde la plantilla del componente que listaba los registros. 

Se puede añadir una nueva funcionalidad a la web para que cuando se realicen cambios en un registro al pulsar el botón "Guardar cambios", el componente programáticamente nos devuelva al listado (redireccionar a otra web). En el método onSubmit() se ejecuta una definición de la ruta: onSubmit() {
    this.presupuesto = this.savePresupuesto();
    this.presupuestoService.putPresupuesto(this.presupuesto, this.id)
          .subscribe(newpres => {
            this.router.navigate(['/presupuestos'])
          });
    this.presupuestoForm.reset();
  }

===============================================================================
Video 051: 051 HTTP Delete_ Eliminar Registros

Borrar registros de la BBDD con la petición delete. 

En el fichero del servicio se implementa la petición delete para borrar un registro concreto de la BBDD Firebase:
1º: se añade un método para recibe como parámetro el identificador de Firebase. Se crea una constante para cargar la ruta para cargar un registro/objeto concreto y obtenerlo en formato json. El método devuelve la respuesta del servidor en formato json y lo que hace es borrar el registro. 

En la plantilla HTML del componente que lista los registros se crea un botón para llamar a un método de borrado (al que se le pasa un id omo parámetro) que se define en el fichero typeScript del mismo componente. 

En el fichero typeScript del componente que lista los registros, en la clase, se define el método al que llama su plantilla y que recibe como parámetro el id del registro. Este método llama al método del Servicio encargado de borrar, pasándole el id, y se suscribe para detectar qué ocurre mostrando el resultado por consola. 

En el navegador, cuando se clica el botón de Eliminar el registro en la base de datos se elimina pero no se actualiza la interfaz hasta que no se refresca la página. Esto se produce porque el array de presupuestos en el componente sigue estando lleno con los registros con lo sque se inicializó. Para evitar esto, ya que se está creando una aplicación SPA (Single Page Application), desde el fichero typeScript del componente que lista los registros, cuando se llame al método de eliminar, se vaciará de contenido el array de registros y para volver a llenarlo, volvemos a cargarlo con el mismo código con el que se inicializa en el constructor. 

===============================================================================
===============================================================================
TEMA 09 Autenticacion de Usuarios
*********************************

===============================================================================
Video 052: 052 Registro

===============================================================================
Video 053: 053 Registro II

===============================================================================
Video 054: 054 Servicio para Autenticacion

===============================================================================
Video 055: 055 Validaciones

===============================================================================
Video 056: 056 Inicio de Sesion

===============================================================================
Video 057: 057 Control de Sesiones de Usuario

===============================================================================
Video 058: 058 Proteccion de Rutas

===============================================================================
Video 059: 059 Links entre Componentes

===============================================================================
===============================================================================
TEMA 10 Modularizacion
**********************

===============================================================================
Video 060: 060 Crear nuevo Modulo

===============================================================================
Video 061: 061 Componente en nuevo Modulo

===============================================================================
Video 062: 062 Codigo del Proyecto Actualizado

===============================================================================
===============================================================================
TEMA 11 Tecnicas de Proyectos
*****************************

===============================================================================
Video 063: 063 Uso Compartido de Objetos

===============================================================================
Video 064: 064 Spinners

===============================================================================
Video 065: 065 Autenticando___

===============================================================================
Video 066: 066 Buscador Reactivo

===============================================================================
Video 067: 067 Upload de Archivos

===============================================================================
Video 068: 068 Upload de Archivos II

===============================================================================
Video 069: 069 Upload de Archivos III

===============================================================================
Video 070: 070 Upload de Archivos IV

===============================================================================
Video 071: 071 Pantalla de Inicio

===============================================================================
===============================================================================
TEMA 12 Despliegue a Produccion
*******************************

===============================================================================
Video 072: 072 Build de la Aplicacion

===============================================================================
Video 073: 073 Despliegue en Amazon Web Services

===============================================================================
===============================================================================
TEMA 13 Anexos
**************

===============================================================================
Video 074: 074 eBook Angular.html

===============================================================================
Video 075: 075 Anexo I Instalacion de Node y NPM.html

===============================================================================
Video 076: 076 Anexo II Instalacion y Configuracion de Visual Studio Code.html

===============================================================================
Video 077: 077 Anexo III TypeScript.html

===============================================================================





