===============================================================================
===============================================================================
TEMA 01 Introduccion_ instalacion y estructura de archivos
**********************************************************

===============================================================================
Video 002: 002 Instalacion de Angular CLI

Para instalar TypeScript:
C:\Users\A702362>npm config set proxy http://10.89.0.72:84
C:\Users\A702362>npm config set https-proxy http://10.89.0.72:84
C:\Users\A702362>npm install -g typescript

Fuente: https://jjasonclark.com/how-to-setup-node-behind-web-proxy/

===============================================================================
Video 003: 003 Arranque de Aplicacion y Estructura de Archivos

Para crear una nueva aplicación (en consola):
ng new appCompras
-------------------------------------
Arrancar el servidor (en consola):
ng serve

Parar el servidor (en consola):
Ctrl+C

Ver el proyecto en navegador: 
localhost:4200
-------------------------------------
Arrancar el servidor en otro puerto (en consola):
ng serve --port 3000

Parar el servidor (en consola):
Ctrl+C

Ver el proyecto en navegador: 
localhost:3000
-------------------------------------
ESTRUCTURA DE ARCHIVOS:
** Fichero index.html
Angular está pensado para hacer aplicaciones en las que el cliente va a ser el navegdor web, por lo tanto, va a tener un archivo index.html en el que se va a renderizar la app (con la etiqueta <app-root></app-root>).

** Fichero favicon.ico
Icono de la página web.

** Fichero styles.css
Estilos css globales para toda la aplicación.

** Fichero package.json
Dependencias, paquetes o librerías de angular que vamos a utilizar en la aplicación y que se instalan en la carpeta node-modules. 

** Directorio src
Donde se va a encontrar los archivos con el código.

** Directorio assets
Los archivos estáticos, especialmente las imágenes.

** Directorio app
Los módulos y componentes de la aplicación. Como está modularizada la aplicación. CLI automáticamente crea unos módulos al inicio. 

===============================================================================
Video 004: 004 Modulos y Componentes en Angular

Todos los módulos tienen que tener al menos un componente.

COMPONENTE: en el fichero typeScript (nombre.component.ts) es donde se define la lógica del componente. Tiene 3 bloques de código: 
** Importaciones: 
Importa paquetes/clases de Angular para hacer la aplicación lo más ligera posible. 
** Decorador: 
@Component: tiene un objeto con 3 metadatos: selector (el componente se va a renderizar en la etiqueta que define 'app-root'), templateUrl (donde está la plantilla html) y styleUrls (donde está la hoja u hojas con los estilos de este componente concreto).
** Exportaciones: 
Exporta la clase del componente (ej. nombreComponent) y en la clase reside la lógica del componente.

MÓDULO:
** Importaciones: 
Importa paquetes/clases de Angular y también importa el componente.
** Decorador: 
@NgModule: tiene un objeto con 3 metadatos: declarations (declaraciones de las clases de los componentes que vamos a utilizar), imports (importa otros módulos) y providers (servicios para utilizarlos en todos los componentes).
-Si es el módulo raíz, el decorador @NgModule tiene otro metadato que es bootstrap, que indica cuál es el componente con el que se va a inicializar el módulo. 
** Exportaciones: 
Exporta la clase del módulo (ej. nombreModule).

El módulo y el componente llegan a index.html porque desde el módulo exportamos la clase del componente, y en el archivo main.ts definimos con  'platformBrowserDynamic().bootstrapModule(nombreModule)' que el módulo va a ser el módulo raíz de la aplicación. 

===============================================================================
Video 006: 006 Creacion de Componentes
Creación de un componente a mano.

===============================================================================
Video 007: 007 Nuevo Componente con Angular CLI

Antes de generar el componente, paramos el servidor desde consola. 

Para generar el componente: 
ng generate component nombrecomponente

Para generar el componente sin archivo spec para los test:
ng generate component copyright --spec false

===============================================================================
Video 008: 008 Componentes Anidados

Para cuando tenemos pocas líneas de código en un componente, podemos hacer una eliminación de ese archivo y poner el código HTML directamente en un metadato del decorador del componente en el fichero typeScript. Cambiamos el metadato "templateUrl: ''" por el metadato "template: `<código HTML>`" (con comillas inclinadas). 

También, podemos anidar componentes introduciendo unos dentro de otros. Se realiza al meter la etiqueta del componente en el metadato "template: `<etiqueta del componente inferior>`" del componente de un nivel superior.

===============================================================================
===============================================================================
TEMA 02 Data Binding
********************

===============================================================================
Video 009: 009 Data Binding_ Introduccion

Data Binding: (unión de datos) en Angular, en los componentes unimos datos entre la plantilla html y la clase del componente que está en el archivo typeScript. 

Hay varias formas:
** One Way Binding: en un sentido, desde la fuente de datos (archivo typeScript) a la vista HTML. Hay 2 fórmulas: Interpolación y Property Binding. 
** One Way Binding: en sentido contrario, desde la vista HTML a la fuente de datos. Tenemos la fórmula: Event Binding.
** Two Way Binding: en ambos sentidos, de la fuente de datos () a la vista HTML y viceversa. Tenemos la fórmula: Two Way Binding.

===============================================================================
Video 010: 010 Interpolacion

Usa la sintaxis "Mustache" de dobles llaves para presentar, de la clase del componente a la plantilla HTML, el valor de una propiedad, el valor de un objeto o una expresión JavaScript. 

1º: creación de una clase constructora de un objeto en angular: a través de un archivo nombre.modelo.ts, que contiene la exportación de la clase, la definición de las propiedades publicas de la clase y el constructor del objeto. Los archivos de clases se crean dentro de la carpeta modelos en la ruta de la ruta src/nombreaplicacion/modelos. 

2º: una vez creado el objeto, vamos a crear un componente:
ng g c nombrecomponente --spec false
(g=generate c=componente)

3º: en el componente, en el fichero typeScript, importamos el objeto y en la clase creamos el objeto. 

4º: en la plantilla HTML del componente metemos un código HTML en el que usamos la interpolación poniendo las propiedades del objeto dentro de las dobles llaves y con la notación del punto nombreobjeto.propiedad)

===============================================================================
Video 011: 011 Interpolacion con Metodos

Utilizar la interpolación para pasar un metodo de la clase del componente a la plantilla del componente.

1º: una vez creado el objeto, vamos a crear un componente:
ng g c nombrecomponente --spec false
(g=generate c=componente)

2º: en la clase del componente creamos una propiedad y la inicializamos. Luego creamos un método metodo(), por ejemplo que devuelva la propiedad creada.

3º: en la plantilla HTML del componente metemos un código HTML en el que usamos la interpolación llamando al método dentro de las dobles llaves {{ metodo() }}.

===============================================================================
Video 012: 012 Property Binding

De la clase del componente a la plantilla. Se aprovecha cualquier atributo que tenga un elemento HTML para asociarlo con una expresión que provenga del componente. Se usan los corchetes en el atributo de HTML y su valor se obtiene del fichero typeScript (tanto de una declaración como de un método).

===============================================================================
Video 013: 013 Event Binding

Manda datos de la plantilla HTML a la clase del componente aprovechando los eventos HTML5. 

Se pone el evento a usar y se iguala a un método que se va a declarar en el componente. 

===============================================================================
Video 014: 014 Two Way Binding

Se pasan los datos en ambos sentidos. 

1º: en la plantilla HTML se usa la sintaxix "Banana box" en las propiedades de un elemento HTML [(directiva)]="propiedaddelaclase".

2º: en la clase del componente se define la propiedad y la directiva es la que se encarga de almacenar la información y pasarla de la clase de la propiedad a la plantilla y viceversa.

3º: hay que fijarse en el módulo nombre.module.ts para comprobar si se ha importado FormsModule:
import { FormsModule } from '@angular/forms';

===============================================================================
===============================================================================
TEMA 03 Directivas
******************

===============================================================================
Video 015: 015 Directivas_ Introduccion

Las directivas son clases Angular con código para crear, formatear e interaccionar con los elementos HMTL en el DOM de las páginas web. 

Hay 3 tipos de directivas:
** Componentes: 
Normalmente no nos referimos a los componentes como directivas.

** Estructurales: 
Son las que alteran el layout o presentación del elemento HTML en el que las introducimos. Se preceden siempre de * (asterisco).
  <elementoHTML *DIRECTIVA="EXPRESION"></elementoHTML>

** De atributos: 
No modifican el layout. Funcionan como un atributo HTML. Van entre corchetes.
  <elementoHTML [DIRECTIVA]="{EXPRESION}"></elementoHTML>

Podemos crear nuestras propias directivas.

===============================================================================
Video 016: 016 ngIf

Es de tipo estructural (modifica el DOM).

ngIf: se mostrará el elemento HTML donde la hemos puesto si se cumple la expresión que tiene a continuación.

  <elementoHTML propiedades="" *ngIf="expresion1"></elementoHTML>

===============================================================================
Video 017: 017 ngIf + else

Es de tipo estructural (modifica el DOM).

ngIf + else: se mostrará el elemento HTML donde la hemos puesto si se cumple la expresión que tiene a continuación el if. Después de la expresión que queremos que se cumpla con ngIg, se pone "; else" y una id. Esa id es una id local de un etiqueta de Angular llamada ng-template. Se define esa etiqueta <ng-template #nombredeidlocal> a continuación del elemento HTML que lleva la directiva y dentro del código de la etiqueda se va a mostrar con el else de la directiva ngIf.  
  <elementoHTML propiedades="" *ngIf="expresion1; else nombredeidlocal">          
  </elementoHTML>
  <ng-template #nombredeidlocal>
    <elementoHTML propiedades=""></elementoHTML>
  </ng-template>

===============================================================================
Video 018: 018 ngIf + else con metodos

Es de tipo estructural (modifica el DOM).

ngIf + else con métodos: se mostrará el elemento HTML donde la hemos puesto si se cumple la expresión que tiene a continuación el if. Después de la expresión que queremos que se cumpla con ngIg, se pone "; else" y una id. Esa id es una id local de un etiqueta de Angular llamada ng-template. Se define esa etiqueta <ng-template #nombredeidlocal> a continuación del elemento HTML que lleva la directiva y dentro del código de la etiqueda se va a mostrar con el else de la directiva ngIf.  

La expresión de los condicionales puede ser la llamada a un método que se definirá en el fichero typeScript del componente.

===============================================================================
Video 019: 019 ngStyle

Es de atributo (no modifica el layout del DOM).

ngStyle: determina el estilo del elemento HTML en función de la expresión que pongamos dentro entre llaves. 

  <elementoHTML [ngStyle]="{EXPRESION}"></elementoHTML>

  <elementoHTML [ngStyle]="{propiedadcss: metodo()}"></elementoHTML>
===============================================================================
Video 020: 020 ngClass

Es de atributo (no modifica el layout del DOM).

ngClass: actúa dinámicamente en las clases de los elementos HTML. Aplica la clase  css que indica entre las llaves cuando la expresión se cumpla. 

  <elementoHTML [ngClass]="{ nombreclasecss: EXPRESION }"></elementoHTML>

===============================================================================
Video 021: 021 ngFor

Es de tipo estructural (modifica el DOM).

ngFor: para iterar arrays, etc. y mostrar tantos elementos HTML como iteraciones se realicen.

  <elementoHTML *ngFor="let variablelocal of array">{{ variablelocal }}          </elementoHTML>

===============================================================================
Video 022: 022 ngFor con objetos

Es de tipo estructural (modifica el DOM).

ngFor con objetos: para iterar objetos. Los objetos se declaran y definen en el fichero typeScript. Por ejemplo, objetos procedentes de una clase que se tenga en el proyecto y que se pueden meter en un array. En la plantilla HTML, se itera el array y se accede a las propiedades de los objetos mediante la notación del punto () 
  <elementoHTML>{{ variablelocal.propiedad }}</elementoHTML>

===============================================================================
Video 023: 023 ngSwitch

Es de atributo (no modifica el layout del DOM).

ngSwitch: asignamos la directiva a una propiedad o variable y dependiendo del valor que ésta tenga, realizará una expresión u otra que se le indique. Por ejemplo, aplicar una clase de CSS. Por cada valor o condición, se crea un elemento HTML asociado a la expresión.

Ejemplo: 
  <li *ngSwitchCase="'valor'" class="clase1">
    <h4>{{ objeto.propiedad }} | {{ objeto.propiedad }}</h4>
  </li>
  <li *ngSwitchCase="'valor'" class="clase2">
    <h4>{{ objeto.propiedad }} | {{ objeto.propiedad }}</h4>
  </li>

===============================================================================
Video 024: 024 Creacion de Directivas Propias

Para crear la directiva se puede utilizar la herramienta de modo de comando de CLI (se crea el fichero nombredirectiva.directive.ts):
ng generate directive nombredirectiva

Para aplicar la directiva:
En la plantilla HTML del componente, en cada elemento HTML en el que se quiera aplicar la directiva, se pone el nombre de la misma que se obtiene en el fichero nombre.directive.ts en el metadato "selector" del decorador @Directive.

La directiva creada automáticamente (y en nombre.module.ts se importa y se declara automáticamente) tiene:
** Importaciones:
Se importa la clase Directive del core de Angular. 
** Decorador:
@Directive: indica el nombre que va a tener la directiva para luego poder implementarla en los componentes.
** Exportaciones: 
Exporta la clase donde va el código que va a realizar la directiva. 

Las directivas propias permiten implementar otras clases y decoradores que proporciona Angular. Estas clases se han de importar en la directiva y se implementan como decoradores (con @) en la clase de la directiva. 
  @ClaseImportada(EXPRESION) 

  Ejemplos:
  @HostBinding('class.clasecss') private propiedad: tipo;

  @HostListener('evento') metodo() {
    //Código del método
  }

Si estamos aplicando una clase CSS, como la idea es que se pueda usar en toda la aplicación, se incluirá en el fichero src/styles.css

===============================================================================
Video 025: 025 Datos entre Componentes_ @Input

Para pasar PROPIEDADES entre componentes.

Si queremos que una propiedad de una clase en un componente hijo reciba el valor de otro componente padre:

1º: en el componente hijo, en el fichero typeScript se importa la clase Input del core de Angular y en la clase del componente en la declaración de la propiedad se usa el decorador @Input(). En la plantilla HTML se hace referencia por interpolación a esa propiedad. 

En hijo.component.ts:
  export class HijoComponent implements OnInit {
    @Input() propiedadHijo: tipo;
  }

En hijo.component.html:
  <elementoHTML>{{ propiedadHijo }}</elementoHTML>

2º: en el componente padre, en el fichero typeScript se declara la propiedad cuyo valor se va a pasar al componente hijo. En la plantilla HTML, se incorpora la etiqueta que anida el componente hijo <app-hijo> y en esa etiqueta se pone el nombre de la propiedad en el hijo entre corchetes asociado al nombre de la propiedad del componente padre.

En padre.component.ts:
  export class PadreComponent implements OnInit {
    propiedadPadre: tipo = 'Valor que se va a inyectar del padre al hijo';
  }

En padre.component.html:
  <elementoHTML class="padre">
      <app-hijo [propiedadHijo]="propiedadPadre"></app-hijo>
  </elementoHTML>
-------------------------------------------------------------------------------
En el caso de un array:

En Angular tiene bastante utilidad cuando queremos de un array disponer de un componente generalista donde estén todos los elementos que sería el padre y de un componente hijo donde se tendrían los detalles. 

En hijo.component.ts (no hay cambios):
  export class HijoComponent implements OnInit {
    @Input() propiedadHijo: tipo;
  }

En hijo.component.html (no hay cambios):
  <elementoHTML>{{ propiedadHijo }}</elementoHTML>

En padre.component.ts:
  export class PadreComponent implements OnInit {
    arrayEnPadre: tipo[] = ['valor 1', 'valor 2', 'valor 3'];
  }

En padre.component.html:
  <elementoHTML class="padre">
    <app-hijo *ngFor="let variablelocal of arrayEnPadre" 	[propiedadHijo]="variablelocal"></app-hijo>
  </elementoHTML>

===============================================================================
Video 026: 026 Datos entre Componentes_ @Output

Para pasar MÉTODOS entre componentes.

Si queremos pasar el valor de una propiedad de un componente hijo mdiante métodos a una propiedad del componente padre:

1º: en el componente hijo, en el fichero typeScript se importa la clase Output del core de Angular (y otras clases que se necesiten como EventEmitter) y en la clase del componente en la declaración de la propiedad se usa el decorador @Output(). En la plantilla HTML se hace al método. 

En hijo.component.ts:
  export class HijoComponent implements OnInit {
    @Output() propiedadHijo = new EventEmitter();

    metodoHijo() {
      // Código donde se hace referencia a la propiedadHijo
      // En la propiedadHijo se emite lo que hya en el código
      propiedadHijo.emit(codigo);
    }
  }
o 
  export class HijoComponent implements OnInit {
    @Output() propiedadHijo: tipo;
    
    metodoHijo() {
      // Código donde se hace referencia a la propiedadHijo
      // En la propiedadHijo se emite lo que hya en el códigog
      propiedadHijo.emit(codigo);
    }
  }

En hijo.component.html:
  <elementoHTML (evento)="metodoHijo()"></elementoHTML>

2º: en el componente padre, en el fichero typeScript se define el método del padre y recoge el evento (por ejemplo, dentro de una propiedadPadre). En la plantilla HTML, se incorpora la etiqueta que anida el componente hijo <app-hijo> y en esa etiqueta se pone el nombre de la propiedad en el hijo entre paréntésis asociado al nombre del método del componente padre y fuera de la etiqueta del hijo, se pone un elemento HTML que recoja la propiedad en el padre.

En padre.component.ts:
  export class PadreComponent implements OnInit {
    propiedadPadre: tipo;

    metodoPadre(event) {
      propiedadPadre = event;
    }
  }

En padre.component.html:
  <elementoHTML class="padre">
      <app-hijo (propiedadHijo)="metodoPadre()"></app-hijo>
  </elementoHTML>

En la plantilla HTML, cuando un evento tiene varios métodos, éstos se separan por punto y coma:
  <elementoHTML (evento)="metodo1(); metodo2()"></elementoHTML>

En la plantilla HTML, cuando un evento tiene un método que tiene que recibir el evento como parámetro se escribe entre el paréntesis (metodo($event))
  <elementoHTML (evento)="metodo($event)"></elementoHTML>

===============================================================================
===============================================================================
TEMA 04 Pipes
*************

Los pipes se emplean para dar formato de salida a los valores que se emplean en la aplicación.

===============================================================================
Video 027: 027 Pipe Date

Pipe Date: para dar formato a fechas (hora y uso horario). El nombre del pipe es 'date'.

Ejemplos:
  <p>Madrid, {{ hoy | date: 'd/M/y H:m' }}</p>
  SALIDA: Madrid, 14/8/2019 13:36
  <p>Madrid, {{ hoy | date: 'd-M-y' }} a las {{hoy | date: 'H:m Z'}}</p>
  SALIDA: Madrid, 14-8-2019 a las 13:36 +0200

===============================================================================
Video 028: 028 Pipe Uppercase y Lowercase

Pipe Uppercase: modifica las cadenas de texto a mayúsculas. El nombre del pipe es 'uppercase'.

Pipe Lowercase: modifica las cadenas de texto a minúsculas. El nombre del pipe es 'lowercase'.

Ejemplos:
  Siendo ciudad tipo string = Madrid:
    <p> {{ ciudad | uppercase }} es mi ciudad</p>
    SALIDA: MADRID es mi ciudad
    <p> {{ ciudad | lowercase }} es mi ciudad</p>
    SALIDA: madrid es mi ciudad

===============================================================================
Video 029: 029 Pipe Decimal

En javaScript para los decimales se utiliza el punto. 

Pipe Decimal: para formatear números. El nombre del pipe es 'number'. Las opciones indican: dígitos enteros que va a tener la presentación del número.número mínimo de dígitos decimales-número máximo de dígitos decimales

Ejemplos:
  Siendo resultado tipo number = 1.148:
    <p>El resultado es {{ resultado | number: '3.2-2' }}</p>
    SALIDA: El resultado es 001.15
  Siendo resultado tipo number = 1.2:
    <p>El resultado es {{ resultado | number: '3.2-2' }}</p>
    SALIDA: El resultado es 001.20

===============================================================================
Video 030: 030 Pipe Currency

Pipe Currency: para utilizar con monedas. El nombre del pipe es 'currency'. Las opciones indican: 'código de la moneda': true (para que se muestre el símbolo de la moneda).

Ejemplos:
  Siendo dolareuro tipo number = 0.88;
    <p>El cambio del dólar es de {{ dolareuro | currency: 'EUR': true }}</p>
    SALIDA: El cambio del dólar es de 0.88
    <p>El cambio del dólar es de {{ dolareuro | currency: 'EUR': false }}</p>
    SALIDA: El cambio del dólar es de EUR0.88

===============================================================================
Video 031: 031 Pipe i18nSelect

Pipe i18nSelect: para establecer el valor de una propiedad en función del valor de otra. 
En nombre.component.ts:
  export class EjpipesComponent implements OnInit {
    propIndependiente : tipo = 'valor1Indep';
    propDependiente: any = {'valor1Indep':'valor1Dep', 'valor2Indep':'valor2Dep'};
    }

En nombre.component.html:
  <p>{{ propiedadIndependiente | i18nSelect: propiedadDependiente }}</p>

Ejemplos:
  En nombre.component.ts:
    export class EjpipesComponent implements OnInit {
      nombre1: string = 'Laura';
      sexo1: string = 'mujer';
      nombre2: string = 'Pedro';
      sexo2: string = 'hombre';
      encabezamiento: any = {'hombre':'Estimado', 'mujer':'Estimada'};
    }
  En nombre.component.html:
    <p>{{ sexo1 | i18nSelect: encabezamiento }} {{ nombre1 }}</p>
  SALIDA: Estimada Laura
  En nombre.component.html:
    <p>{{ sexo2 | i18nSelect: encabezamiento }} {{ nombre2 }}</p>
  SALIDA: Estimado Pedro

===============================================================================
Video 032: 032 Creacion de Pipes Propios

Para crear un pipe se puede utilizar la herramienta de modo de comando de CLI (se crea el fichero nombrepipe.pipe.ts):
ng generate pipe nombrepipe

El pipe creado automáticamente (y en nombre.module.ts se importa y se declara automáticamente) tiene:
** Importaciones:
Se importa las dependencias y librerías que necesita para trabajar. Importa Pipe y PipeTransform del core de Angular. 
** Decorador:
@Pipe: indica el nombre que va a tener el pipe para luego poder usarlo. 
** Exportaciones: 
Exporta la clase donde va el código que va a realizar el pipe. La clase implementa la interfaz PipeTransform que nos da un método transform() que modificaremos para obtener la funcionalidad que se desee que realice el pipe:
  transform(value: any, ...args: any[]): any {
    return null;
  }

Para aplicar el pipe se pone su nombre de la misma forma que el resto de pipes. 

===============================================================================
===============================================================================
TEMA 05 Servicios
*****************

===============================================================================
Video 033: 033 Creacion de un Servicio

Los servicios son unos elementos de angular que nos permiten centralizar el código para luego emplearlo en cada componente donde lo necesitemos mediante la inyección de dependencias. Se llaman 'providers' porque se usan para gestionar datos e inyectarlos en los componentes.

Los proyectos suelen tener varios servicios así que lo mejor es reunirlos en un directorio. 

Para crear un servicio se puede utilizar la herramienta de modo de comando de CLI (se crea el fichero nombreservicio.service.ts):
ng generate service nombrecarpeta/nombreservicio --spec false

Cuando se crea puede estar generado pero no provisto, por lo tanto, hay que introducirlo en el archivo app.module.ts importándolo desde la carpeta donde se ha guardado y metiéndolo en el metadato "providers" del decorador @NgModule. 

El archivo del servicio tiene una estructura de código compuesta por: 
** Importaciones:
Se importa la clase Inyectable del core de Angular. 
** Decorador:
@Injectable.
** Exportaciones: 
Exporta la clase donde va el código que va a realizar el sercivio.

Angular implementa un servicio en un componente mediante métodos, para trasladar el código de los servicios a los componentes. La forma de hacerlo es: 

1º: en el fichero typeScript del componente, importando el servicio y en el constructor de la clase usando como parámetro una propiedad nombreservicio e igualándola al nombre de la clase del servicio. Al estar en el constructor, cuando se inicie el componente se va a llamar a ese servicio. El nombre de la propiedad puede ir con letra minúscula, o poniendo delante un guión bajo o poniendo pService.

Ejemplo:
  constructor(private proveedoresService: ProveedoresService) { }
  constructor(private _proveedoresService: ProveedoresService) { }
  constructor(private pService: ProveedoresService) { }

2º: desde el fichero typeScript del componente se llama al método del servicio usando el método ngOnInit() cuya función es que cada vez que se inicialice dentro del ciclo de vida de los componentes angular este componente, llevará a cabo el código que lleva dentro. 

===============================================================================
Video 034: 034 Objetos en Servicios

En el servicio, en la clase, puede haber un array que contenga un conjunto de objetos. Ese array puede ser devuelto por un método dentro de la clase.

  export class nombreservicioService {
    nombreArray: any = [{ objeto1 }, { objeto2 }];
    constructor() { }
    metodoDelServicio() {
      return this.nombreArray; // Devuelve el array
    }

En el componente, desde el método ngOnInit() se llama al método del servicio y se obtiene el valor de los objetos. 

===============================================================================
===============================================================================
TEMA 06 Routing
***************

===============================================================================
Video 035: 035 Implementacion de Routing

Las aplicaciones angular están diseñadas para ser Single Page Application (SPA), con lo que van a contar con una página sobre la cual los componentes se van a ir renderizando sin necesidad de que refresque la página, coniguiendo una aplicación ágil y eficiente. 

Esto no significa que todos los componentes estén en una misma y única página puesto que haría que fuera una aplicación compleja y difícil de manejar por el usuario cuando hay muchos componentes. Para ello se emplea el Routing.

El Routing con la ayuda de la barra de navegación del navegador establece una serie de URL que cargan dinámicamente cada componente. 

A) En el módulo de la aplicación (app.module.ts): 
1º: se importan los paquetes de Routing que son Routes y RouterModule desde @angular/router.

2º: en los imports del decorador @NgModule se importa RouterModule.forRoot(routes) para establecer un array de rutas que va a usar la aplicación para cargar los distintos componentes en la página. 

3º: se crea como una constante el array de rutas. La primera ruta va sin nombre del componente porque va a coincidir con la URL raíz de la aplicación:
  const routes: Routes = [
    { path: '', component: InicioComponent },
    { path: 'nombreruta', component: NombrecomponenteComponent }
  ];

También se puede añadir una ruta con una máscara para que cuando escribamos una ruta que no existe nos derive a ella (ejemplo de la página para error 404): 
    { path: '**', component: NombrecomponenteAlQueDerivar }

B) En la plantilla raíz (app.component.html) de la aplicación se pone la etiqueta de angular <router-outlet> que dinámicamente estable la etiqueta del componente que le diga la ruta. 

===============================================================================
Video 036: 036 Barra de Navegacion

Para crear una barra de navegación con links a las rutas que hemos establecido para el Routing: 

1º: se crea un componente  (por ejemplo lo llamamos header). En la plantilla del componente ponemos una barra de navegación (de bootstrap4 o se crea manualmente o se saca de otro framework). Se personalizan los links con las url de la aplicación: 

  <li class="nav-item" routerLinkActive="active">
      <a class="nav-link" routerLink="/">Inicio </a>
  </li>
  <li class="nav-item" routerLinkActive="active">
      <a class="nav-link" routerLink="/nombreruta">Nombre página</a>
  </li>

2º: En la plantilla raíz (app.component.html) de la aplicación se pone la etiqueta con el nombre del componente que tiene la barra de navegación. 
Ejemplo de app.component.html:
  <app-header></app-header>
  <div class="container">
    <router-outlet></router-outlet>
  </div>  

===============================================================================
===============================================================================
TEMA 07 Formularios
*******************

===============================================================================
Video 037: 037 Template Driven

Los formularios es la parte de la web don de el usuario va a interaccionar introduciendo datos y por ello, son muy importantes. 

Hay dos modalidades para crear formularios en Angular:
** Template Driven: realiza la lógica de captura de datos como la validación de los mismos del lado del archivo HTML. 
** Reactive: gestiona el formulario desde el archivo typeScript.

Ejemplo: creamos un nuevo componente con un formulario. Este componente se incluye en el array de rutas de app.module.ts y se enlaza con algún link en la barra de navegación o algún link de botón. 

===============================================================================
Video 038: 038 Template Driven II

A partir del ejemplo que tenemos, vamos a añadir la lógica. 

1º: antes de empezar, hay que asegurarse que en la aplicación se tiene importado FormsModule que es la librería para gestionar formularios (en app.module.ts):
  import { FormsModule } from '@angular/forms';

2º: en el fichero typeScript del componente que tiene el formulario, en la clase, se declara un objeto en el que se guardarán los datos del formulario y en el constructor se inicializa ese objeto en forma de documento json con sus propiedades con los valores de texto vacíos y los numéricos a null.

3º: se enlazan los datos del formulario con la clase del componente.
1) En la plantilla HTML del componente que tiene el formulario, en la etiqueta del formulario <form> se añade la clase (ngSubmit) de FormsModule y se iguala a un método nuestro para que cuando se le dé al botón Submit angular desencadene el método.
2) En la plantilla HTML del componente que tiene el formulario, también en la etiqueta <form> se identifica el formulario con un id local #formpro="nombreFormulario" para que el objeto que se crea con el formulario (gracias a la importación de la clase FormsModule) tenga esa id local.
3) En la plantilla HTML del componente que tiene el formulario, por último, hay que identificar cada uno de los campos en el objeto del formulario. Dentro de la etiqueta input en cada campo se añade ngModel name="nombrepropiedadobjeto". 

4º: en el fichero typeScript del componente que tiene el formulario, se importa ViewChild del core de Angular y NgForm de los formularios de Angular:
import { ViewChild } from '@angular/core';
import { NgForm } from '@angular/forms';
Dentro de la clase, en modo decorador se añade @ViewChild para hacer una vista del id local del formulario y el nombre de la vista se declara del tipo NgForm. 

5º: el método que se llama a través de (ngSubmit) se declara en la clase en el fichero typeScript del componente que tiene el formulario. En este método se enlaza la propiedad del objeto con el valor de la propiedad del objeto del formulario asociado a esa propiedad.

Si no se tiene una base de datos, pero se quiere comprobar si el objeto se está cargando correctamente en el formulario y en el método, se puede usar en la plantilla HTML del componente que se muestre el objeto por interpolación usando el pipe 'json'.
  <pre>{{ proveedor | json }}</pre>

===============================================================================
Video 039: 039 Carga de Datos en Select

En los formularios los campos de tipo Select son campos con valores fijos de los cuales el usuario tiene que escoger uno de ellos. 

En el fichero typeScript del componente que tiene el formulario, se añade un array con los valores que el usuario tendrá para elegir en el campo Select. 

En la plantilla HTML del componente que tiene el formulario, en el campo que queremos que sea Select ponemos la etiqueta <select> e identificamos con la misma propiedad en el objeto del formulario. También se añade ngModel name="nombrepropiedadobjeto". En las opciones iteramos el array con la directiva *ngFor.

===============================================================================
Video 040: 040 Validaciones HTML

Validaciones de HTML5. Algunas son: required (campo obligatorio), email (el texto cumple con las reglas de un email), etc.

Angular anula las validaciones de HTML5 porque ngForm tiene su propio sistema de validación. Implementa una serie de estados por los que pasa el campo cuando el usuario está utilizando el formulario. Los estados son:
** Dirty: cuando el usuario comienza a utilizar el campo (puslsar sobre el campo y empezar a escribir) es true.
** Pristine: cuando el campo aún no se ha tocado es true.
** Touched: cuando se quita el foco del campo pasa a true
** Valid: el campo cumple con las normas de validación que tiene puestas.
** Invalid: el campo no cumple con las normas de validación que tiene puestas.

Angular tiene asociadas a estos estados una serie de clases CSS que nos permiten configurar las ayudas al usuario a la hora de completar el formulario. También como son propiedades del objeto se pueden utilizar para establecer una lógica en el botón de envío. La forma de enlazar desde el fichero CSS del componente que tiene el formulario es, por ejemplo:
  input.ng-invalid.ng-touched {
    border-left: 5px solid #A94442;
  }
  input.ng-valid.ng-dirty {
    border-left: 5px solid #42A948;
  }

===============================================================================
Video 041: 041 Ayudas Dinamicas

Se pueden añadir mensajes/iconos para que aparezcan en función del estado del campo.

Iconos:
En la plantilla HTML del componente que tiene el formulario, en la etiqueta input hay que poner un id local para identificarlo: 
  #idlocal="ngModel">
Se pueden añadir iconos en los cuales se usa la directiva *ngIf y la condición sea  si el campo cumple un estado u otro: 
   <i class="fa fa-check-circle check" *ngIf="idlocal.valid"></i>
   <i class="fa fa-exclamation-circle uncheck" *ngIf="idlocal.invalid &&         idlocal.touched"></i>

En el ejemplo se han usado iconos de fontawesome (fa=fontawesome) así que se ha de importar al index.html:
  <script src="https://use.fontawesome.com/bacad173cf.js"></script>
 
Mensajes con textos:
Se añade un párrafo en el cual se usa la directiva *ngIf siendo la condición que el campo cumpla un estado u otro:
  <p class="alert alert-danger" *ngIf="idlocal.invalid && idlocal.touched">
            Por favor, introduzca una dirección de correo válida
  </p>


Se puede añadir el atributo "Disable" al botón del submit para que solo se pueda enviar cuando la totalidad del formulario sea válida. 
  <button type="submit" class="btn btn-success"
          [disabled]="!formpro.valid">
          Añadir Proveedor
  </button>

===============================================================================
Video 042: 042 Reactive

Hay dos modalidades para crear formularios en Angular:
** Template Driven: realiza la lógica de captura de datos como la validación de los mismos del lado del archivo HTML. 
** Reactive: gestiona el formulario desde el archivo typeScript.

Reactive tiene aún más control sobre la gestión de los formularios. 
 
En app.module.ts hay que importar la dependencia ReactiveFormsModule desde los formularios de Angular. 
  import { ReactiveFormsModule } from '@angular/forms';

Ejemplo: creamos un nuevo componente con un formulario. Este componente se incluye en el array de rutas de app.module.ts y se enlaza con un link en la barra de navegación.

===============================================================================
Video 043: 043 Reactive II

A partir del ejemplo que tenemos, vamos a añadir la lógica. 

1º: antes de empezar, hay que asegurarse que en la aplicación se tiene importado ReactiveFormsModule que es la librería para gestionar formularios con la técnica Reactive (en app.module.ts):
  import { ReactiveFormsModule } from '@angular/forms';

2º: en el fichero typeScript del componente que tiene el formulario, se importa FormControl, FormGroup y FormBuilder de los formularios de Angular:
  import { FormControl, FormGroup, FromBuilder } from '@angular/forms';

3º: en el fichero typeScript del componente que tiene el formulario, en la clase, se declara un objeto en el que se almacenarán los valores de los campos del formulario y es de la clase FormGroup. También se declara otro objeto donde se van a almacenar los valores de cada nuevo presupuesto. En el constructor .....min 1:57


En el constructor .....min 1:57

se inicializa ese objeto en forma de documento json con sus propiedades con los valores de texto vacíos y los numéricos a null.



4º: 
5º: 
6º: 
7º: 
8º: 



===============================================================================
Video 044: 044 Validacion Programatica



BOOOOOOOOOOOOOOOOOORRAR
3º: se enlazan los datos del formulario con la clase del componente.
1) En la plantilla HTML del componente que tiene el formulario, en la etiqueta del formulario <form> se añade la clase (ngSubmit) de FormsModule y se iguala a un método nuestro para que cuando se le dé al botón Submit angular desencadene el método.
2) En la plantilla HTML del componente que tiene el formulario, también en la etiqueta <form> se identifica el formulario con un id local #formpro="nombreFormulario" para que el objeto que se crea con el formulario (gracias a la importación de la clase FormsModule) tenga esa id local.
3) En la plantilla HTML del componente que tiene el formulario, por último, hay que identificar cada uno de los campos en el objeto del formulario. Dentro de la etiqueta input en cada campo se añade ngModel name="nombrepropiedadobjeto". 

4º:
Dentro de la clase, en modo decorador se añade @ViewChild para hacer una vista del id local del formulario y el nombre de la vista se declara del tipo NgForm. 

5º: el método que se llama a través de (ngSubmit) se declara en la clase en el fichero typeScript del componente que tiene el formulario. En este método se enlaza la propiedad del objeto con el valor de la propiedad del objeto del formulario asociado a esa propiedad.

Si no se tiene una base de datos, pero se quiere comprobar si el objeto se está cargando correctamente en el formulario y en el método, se puede usar en la plantilla HTML del componente que se muestre el objeto por interpolación usando el pipe 'json'.
  <pre>{{ proveedor | json }}</pre>






===============================================================================
Video 045: 045 valueChangues








======================================================================
===============================================================================
TEMA 08 HTTP_ Base de datos en Firebase
***************************************

===============================================================================
Video 046:

===============================================================================














